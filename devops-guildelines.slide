DevOps Guidelines
From development to production
10 Sep 2018
Tags: devops 12-factor-app

Adesegun Adeyemo
Head, Research and Development
Interswitch Group
adesegun.adeyemo@interswitchgroup.com
http://www.interswitch.com
@alexcrownus

* Goals

- To enable applications to be built with portability and resilience when deployed to production
- Declarative formats for setup automation, to minimize time and cost for new developers joining the project
- Minimize divergence between development and production, enabling continuous deployment for maximum agility

* Agenda
- Codebase
- Dependencies
- Config
- Backing services
- Build, release, run
- Processes
- Port binding
- Concurrency
- Disposability
- Dev/prod parity
- Logs
- Admin processes

* Codebase

*Objective:* There should be exactly one codebase for a deployed service with the codebase being used for many deployments.

.image devops-guildelines/codebase-deploys.png

* Codebase (cont'd)

- Multiple apps sharing the same code is a violation
- The solution here is to factor shared code into libraries which can be included through a dependency manager.
- A deploy is a running instance of the app.
- There is only one codebase per app, but there will be many deploys of the app: *DEV*, *UAT*, *PROD/DR* and (optionally) *SANDBOX*
- The codebase is the same across all deploys, although different versions may be active in each deploy.
- For example, a developer has some commits not yet deployed to *UAT*; *UAT* has some commits not yet deployed to *PROD*.
- But they all share the same codebase, thus making them identifiable as different deploys of the same app.

* Dependencies

*Objective:* All dependencies should be declared and isolated, with no implicit reliance on system tools or libraries.

- An application must declare all dependencies, completely and exactly, via a _dependency_ _declaration_ _manifest_.
- *Maven* and *Nuget* for *Java* and *.Net* respectively
- The full and explicit dependency specification is applied uniformly to both production and development.
- One benefit of explicit dependency declaration is that it simplifies setup for developers new to the app.
- The new developer can check out the app’s codebase onto their development machine, requiring only the language runtime and dependency manager installed as prerequisites.
- They will be able to set up everything needed to run the app’s code with a deterministic _build_ _command_.

* Configuration

*Objective:* All configurations that vary between deployment environments should be externalized as environment variables

- Applications having such configurations hardcoded into the applications will be regarded as non-compliant
- Applications should get all such configurations from the environment they are deployed in.
- ConfigMaps and Secrets are one way applications can externalize configurations to the environment on *Kubernetes*.
- Core Technology Team should expose a list of standard configurations for  developers to use within their applications.
- These standard configurations will be centralized and managed by Core Technology and can only be updated by Core Technology Team.
- Both applications on *Kubernetes* and legacy applications can take advantage of this, all existing applications should be refactored to use environment variables.

* Backing Services

*Objective:* All backing services should be treated as attached resources and attached and detached by the execution environment.

.image devops-guildelines/attached-resources.png

* Backing Services (cont'd)

- Applications that hardcode URL or locator/credentials for backing services will be regarded as non-compliant.
- A backing service is something external your app depends on, like a database or messaging service.
- Applications should declare and access backing services via an external configuration.
- Local and 3rd Party Services are regarded as the same and should be treated as such.
- All parameters required to access a backing service should be externalized as was described in configuration section.
- This will enable you attach and detach these services without restarting the application.

* Build, release, run

*Objective:* The delivery pipeline should strictly consist of build, release, run.

.image devops-guildelines/release.png

* Build, release, run (cont'd)

- A single codebase is taken through a *build* process to produce a single executable artifact.
- This build is merged with configuration information external to the app that is based on execution environment (dev, uat, prod). This combination of build and configuration makes a *release*.
- This release is then delivered to the execution environment and *run*.
- This speaks directly to CI/CD which is currently being managed by Jenkins.
- Applications that do not have a CI/CD pipeline defined on Jenkins will be regarded as non-compliant.
- This means Jenkins end to end managing the build, the release and the deployment to the execution environment.
